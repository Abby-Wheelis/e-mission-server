from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future import standard_library
standard_library.install_aliases()
from builtins import *
import unittest
import os
from emission.core.wrapper.trip_old import Coordinate
import requests
import bin.createfakeplace as bc 
import emission.core.wrapper.entry as ecwe
import emission.net.ext_service.geocoder.nominatim as eco
import emission.analysis.intake.cleaning.clean_and_resample as clean

#Sets OPENSTREETMAP_QUERY_URL to the environment variable.
OPENSTREETMAP_QUERY_URL_env = os.environ.get("OPENSTREETMAP_QUERY_URL")

OPENSTREETMAP_QUERY_URL = (
    OPENSTREETMAP_QUERY_URL_env if OPENSTREETMAP_QUERY_URL_env is not None 
    else eco.OPENSTREETMAP_QUERY_URL
)

GFBK = os.environ.get("GFBK_KEY")

GEOFABRIK_QUERY_URL = (
    "https://geocoding.geofabrik.de/{}".format(GFBK) if GFBK is not None
    else print("No key available")
)
class NominatimTest(unittest.TestCase):
    maxDiff = None

    #Basic query to check that nominatim and geofabrik are returning the same data.
    def test_geofabrik_and_nominatim(self):
        OPENSTREETMAP_result = requests.get(OPENSTREETMAP_QUERY_URL + "/reverse?lat=41.8239891&lon=-71.4128343&format=json").json()
        geofabrik_result = requests.get(GEOFABRIK_QUERY_URL + "/reverse?lat=41.8239891&lon=-71.4128343&format=json").json()
        key_list = ['osm_id', 'boundingbox']
        for k in key_list:
            self.assertEqual(OPENSTREETMAP_result[k], geofabrik_result[k])

    #Checks the display name generated by get_filtered_place in clean_and_resample.py, which creates a cleaned place from the fake place
    # and reverse geocodes with the coordinates.
    def test_get_filtered_place(self):
        fake_place_raw = bc.create_fake_place()
        fake_place_data = clean.get_filtered_place(fake_place_raw).__getattr__("data")
        actual_result = fake_place_data.__getattr__("display_name")
        expected_result = "Dorrance Street, Providence"
        self.assertEqual(expected_result, actual_result)

    #Testing make_url_geo, which creates a query URL from the input string. 
    def test_make_url_geo(self):
        expected_result = OPENSTREETMAP_QUERY_URL + "/search?q=Providence%2C+Rhode+Island&format=json"
        actual_result = eco.Geocoder.make_url_geo("Providence, Rhode Island")
        self.assertEqual(expected_result, actual_result)

    #Testing get_json_geo, which passes in an address as a query. Compares three select k,v pairs in the results. 
    def test_get_json_geo(self):
        expected_result = {'place_id': 132490, 'licence': 'Data Â© OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright', 'osm_type': 'way', 'osm_id': 141567710, 'boundingbox': ['41.8325787', '41.8332278', '-71.4161848', '-71.4152064'], 'lat': '41.8330097', 'lon': '-71.41568124868104', 'display_name': 'State of Rhode Island Department of Administration, 1, Park Street, Downtown, Providence, Providence County, 02908, United States', 'class': 'building', 'type': 'civic', 'importance': 1.75001}
        actual_result = eco.Geocoder.get_json_geo("State of Rhode Island Department of Administration, 1, Park Street, Downtown, Providence, Providence County, 02908, United States")[0]
        key_list = ['osm_id', 'boundingbox', 'display_name']
        for k in key_list:
            self.assertEqual(expected_result[k], actual_result[k])

    #Testing the geocode function, which passes in an address and gets latitude and longitude.
    # Test creates instance of coordinates using coordinate class. Getting lat and lon of the coordinate using get_lat and get_lon methods from the class.
    def test_geocode(self):
        expected_result_lon = Coordinate(41.8239891, -71.4128343).get_lon()
        expected_result_lat = Coordinate(41.8239891, -71.4128343).get_lat()
        actual_result = eco.Geocoder.geocode("Providence, Rhode Island")
        actual_result_lon = actual_result.get_lon()
        actual_result_lat = actual_result.get_lat()
        self.assertEqual(expected_result_lon, actual_result_lon)
        self.assertEqual(expected_result_lat, actual_result_lat)

    #Testing make_url_reverse, which creates a query url from a lat and lon
    def test_make_url_reverse(self):
        expected_result = OPENSTREETMAP_QUERY_URL + "/reverse?lat=41.8239891&lon=-71.4128343&format=json"
        actual_result = (eco.Geocoder.make_url_reverse(41.8239891, -71.4128343))
        self.assertEqual(expected_result, actual_result)
 
    #Testing get_json_reverse, which reverse geocodes from a lat and lon. Tested result was modified to only look at the name returned with the coordinates, rather than the entire dictionary.
    def test_get_json_reverse(self):
        expected_result = "Providence City Hall"
        actual_result = eco.Geocoder.get_json_reverse(41.8239891, -71.4128343)["display_name"].split(",")[0]
        self.assertEqual(expected_result, actual_result)

    #Testing reverse_geocode, which reverse geocodes from a lat and lon and returns only the display name. 
    def test_reverse_geocode(self):
        expected_result = "Portugal Parkway, Fox Point, Providence, Providence County, 02906, United States"
        actual_result = eco.Geocoder.reverse_geocode(41.8174476, -71.3903767)
        self.assertEqual(expected_result, actual_result)

    #Compares the result of a hard-coded nominatim call with our container. 
    def test_nominatim_api(self):
        nominatim_url = "http://nominatim.openstreetmap.org/reverse?lat=41.832942092439694&lon=-71.41558148857203&format=json"
        nominatim_result_raw = requests.get(nominatim_url)
        nominatim_result = nominatim_result_raw.json()['display_name'][0:70]
        docker_result = eco.Geocoder.reverse_geocode(41.832942092439694, -71.41558148857203)[0:70]
        self.assertEqual(nominatim_result, docker_result)

if __name__ == '__main__':
    unittest.main()