diff --git a/bin/check_for_yelp_suggestions.py b/bin/check_for_yelp_suggestions.py
index 05ead509..46efd64e 100644
--- a/bin/check_for_yelp_suggestions.py
+++ b/bin/check_for_yelp_suggestions.py
@@ -23,7 +23,8 @@ def calculate_single_yelp_suggestion(UUID):
 	logging.debug("About to calculate single suggestion for %s" % UUID)
 	yelp_suggestion_trips = edb.get_yelp_db()
     all_users = pd.DataFrame()
-    user_id = all_users.iloc[all_users[all_users.uuid == uuid].index.tolist()[0]].uuid
+    user_id = UUID
+    #TO ADDRESS PREVIOUS PULL REQUEST COMMENTS, have not yet hooked up the database with the suggestion trips
     time_series = esta.TimeSeries.get_time_series(user_id)
     cleaned_trips = time_series.get_data_df("analysis/cleaned_trip", time_query = None)
     num_cleaned_trips = len(cleaned_trips)
diff --git a/emission/core/wrapper/suggestion_sys.py b/emission/core/wrapper/suggestion_sys.py
index 8a3a7ee5..9e1bd594 100644
--- a/emission/core/wrapper/suggestion_sys.py
+++ b/emission/core/wrapper/suggestion_sys.py
@@ -11,6 +11,7 @@ import emission.storage.timeseries.abstract_timeseries as esta
 import argparse
 import pprint
 import requests
+import os
 
 
 try:
@@ -31,15 +32,26 @@ except ImportError:
 # You can find it on
 # https://www.yelp.com/developers/v3/manage_app
 
-google_maps_json = open('conf/net/ext_service/googlemaps_destination.json', 'r')
+google_maps_path = 'conf/net/ext_service/googlemaps.json'
+yelp_json_path = 'conf/net/ext_service/yelpfusion.json'
+nominatim_path = 'conf/net/ext_service/nominatim.json'
+"""
+Checks if conf files exists or not. The conf files will be given to the user through request.
+"""
+assert os.path.exists(google_maps_path), "File %s not found" % google_maps_path
+assert os.path.exists(yelp_json_path), "File %s not found" % yelp_json_path
+assert os.path.exists(nominatim_path), "File %s not found" % nominatim_path
+
+google_maps_json = open('conf/net/ext_service/googlemaps.json', 'r')
 yelp_json = open('conf/net/ext_service/yelpfusion.json', 'r')
 nominatim = open('conf/net/ext_service/nominatim.json', 'r')
 
+
 google_maps_auth = json.load(google_maps_json)
 yelp_auth = json.load(yelp_json)
 nominatim_auth = json.load(nominatim)
 
-API_KEY = yelp_auth['api_key']
+YELP_API_KEY = yelp_auth['api_key']
 ACCESS_TOKEN = google_maps_auth['access_token']
 JACK_TOKEN = google_maps_auth['backup_access_token']
 
@@ -58,7 +70,9 @@ LAT_URL = nominatim_auth['lat']
 LON_URL = nominatim_auth['lon']
 
 
-#Helper function to query into Yelp's API
+"""
+YELP API: Helper function to query into the API domain. Will change to requests instead of urllib later on.
+"""
 def request(host, path, api_key, url_params=None):
     """Given your API_KEY, send a GET request to the API.
     Args:
@@ -83,6 +97,9 @@ def request(host, path, api_key, url_params=None):
 
     return response.json()
 
+"""
+YELP API: Function to query based on search terms
+"""
 def search(api_key, term, location):
     """Query the Search API by a search term and location.
     Args:
@@ -99,22 +116,34 @@ def search(api_key, term, location):
     }
     return request(API_HOST, SEARCH_PATH, api_key, url_params=url_params)
 
+"""
+YELP API: Function to retrieve all reviews related to the business. 
+"""
 def business_reviews(api_key, business_id):
     business_path = BUSINESS_PATH + business_id
 
     return request(API_HOST, business_path, api_key)
 
-def title_category(json_file):
+"""
+YELP API: Returns the title of the business category in the API call
+"""
+def title_of_category(json_file):
     return json_file["categories"][0]["title"]
 
-#Not as accurate compared to the below functions
+"""
+YELP API: Obtains the business ID through latitude, longitude
+"""
 def get_business_id(api_key, lat, lon):
     url_params = {
         'location': lat + ',' + lon
     }
     return request(API_HOST, SEARCH_PATH, api_key, url_params=url_params)
 
-#Used first semester's code to obtain the business ID and location in order to find address
+"""
+Google API: Gets business name through Google's API query - not very accurate based on location 
+NOTE: Transitioning to Nominatim - will not use this anymore - here in case Nominatim functions 
+go horribly wrong.
+"""
 def check_against_business_location(location='0, 0', address = ''):
     if not re.compile('^(\-?\d+(\.\d+)?),\s*(\-?\d+(\.\d+)?)$').match(location):
         raise ValueError('Location Invalid')
@@ -151,21 +180,24 @@ def check_against_business_location(location='0, 0', address = ''):
 
 
 """
-    Creates a Nominatim API Call, returns address in string form and dictionary form separated by streetname, 
+NOMINATIM API: Creates a Nominatim API Call, returns address in string form and dictionary form separated by streetname, 
     road, neighborhood, etc
 """
 def return_address_from_location_nominatim(lat, lon):
     base_url = NOMINATIM_URL
-    lat_lon = 'lat=' + LAT_URL + '&lon=' + LON_URL
+    lat_lon = LAT_URL + lat + LON_URL + lon
     zoom = ZOOM
     try: 
         url = base_url + lat_lon + zoom
+        # print(url)
         result = requests.get(url).json()
         return result["display_name"], result["address"]
     except:
         raise ValueError("Something went wrong")
 
-
+'''
+GOOGLE API: Makes Google Maps API CALL to the domain and returns address given a latitude and longitude
+'''
 def return_address_from_location_google(location='0,0'):
     """
     Creates a Google Maps API call that returns the addresss given a lat, lon
@@ -209,14 +241,18 @@ def return_address_from_location_google(location='0,0'):
         except:
             raise ValueError("Something went wrong")
 
+'''
+YELP API: Function to find the business matching the address
+'''
 def match_business_address(address):
     business_path = SEARCH_PATH
     url_params = {
         'location': address.replace(' ', '+')
     }
-    return request(API_HOST, business_path, API_KEY, url_params)
+    return request(API_HOST, business_path, YELP_API_KEY, url_params)
+
 '''
-Function to find the review of the original location of the end point of a trip
+YELP API: Function to find the review of the original location of the end point of a trip
 '''
 def review_start_loc(location = '0,0'):
     try:
@@ -226,7 +262,7 @@ def review_start_loc(location = '0,0'):
         if (len(return_address_from_location_google(location)) == 3):
             business_name, city, address = return_address_from_location_google(location)
         #print(business_reviews(API_KEY, business_name.replace(' ', '-') + '-' + city))
-            return business_reviews(API_KEY, business_name.replace(' ', '-') + '-' + city)['rating']
+            return business_reviews(YELP_API_KEY, business_name.replace(' ', '-') + '-' + city)['rating']
     except:
         try:
             #This EXCEPT part may error, because it grabs a list of businesses instead of matching the address to a business
@@ -236,7 +272,7 @@ def review_start_loc(location = '0,0'):
             raise ValueError("Something went wrong")
     
 '''
-Function that RETURNS a list of categories that the business falls into
+YELP API: Function that RETURNS a list of categories that the business falls into
 '''
 def category_of_business(location = '0,0'):
     try:
@@ -247,7 +283,7 @@ def category_of_business(location = '0,0'):
         if (len(return_address_from_location_google(location)) == 3):
             business_name, city, address = return_address_from_location_google(location)
             categories = []
-            for c in business_reviews(API_KEY, business_name.replace(' ', '-') + '-' + city)['categories']:
+            for c in business_reviews(YELP_API_KEY, business_name.replace(' ', '-') + '-' + city)['categories']:
                 categories.append(c['alias'])
             return categories
         else:
@@ -270,11 +306,11 @@ def category_of_business_nominatim(lat, lon):
         # print(len(return_address_from_location_google(location)))
         #IF RETURN_ADDRESS_FROM_LOCATION HAS A BUSINESS LOCATION ATTACHED TO THE ADDRESS
         string_address, address_dict = return_address_from_location_nominatim(lat, lon)   
-        business_key = list(address_dict['address'].keys())[0]
-        business_name = address_dict['address'][business_key]
-        city = address_dict['address']['city']
+        business_key = list(address_dict.keys())[0]
+        business_name = address_dict[business_key]
+        city = address_dict['city']
         categories = []
-        for c in business_reviews(API_KEY, business_name.replace(' ', '-') + '-' + city)['categories']:
+        for c in business_reviews(YELP_API_KEY, business_name.replace(' ', '-') + '-' + city)['categories']:
             categories.append(c['alias'])
         return categories
         
@@ -321,59 +357,13 @@ def geojson_to_lat_lon_separated(geojson):
     lon = str(coordinates[0])
     lat = str(coordinates[1])
     return lat, lon
-'''
-Determines the motion type in words from sensed mode.
-(NOTE ***): FIX ENUMS TO STRING 
-'''
-def sensed_to_motion_type(value):
-    if value == 0:
-        return "IN_VEHICLE"
-    elif value == 1:
-        return "BIKING"
-    elif value == 2:
-        return "ON_FOOT"
-    elif value == 3:
-        return "STILL"
-    elif value == 4:
-        return "UNKNOWN"
-    elif value == 5:
-        return "TILTING"
-    elif value == 7:
-        return "WALKING"
-    elif value == 8:
-        return "RUNNING"
-    elif value == 9:
-        return "NONE"
-    elif value == 10:
-        return "STOPPED_WHILE_IN_VEHICLE"
-    elif value == 11:
-        return "AIR_ON_HSR"
 
 '''
-Updated check_mode_from_trip to 
+REWRITE def check_mode_from_trip(cleaned_trip, cleaned_sections, section_counter, trip_counter): 
 '''
-def check_mode_from_trip(cleaned_trip, cleaned_sections, section_counter, trip_counter):
-    end_location = cleaned_trip.iloc[trip_counter]["end_loc"]
-    end_loc_lat, end_loc_lon = geojson_to_lat_lon_separated(end_location)
-    endsec_location = cleaned_sections.iloc[section_counter]["end_loc"]
-    endsec_loc_lat, endsec_loc_lon = geojson_to_lat_lon_separated(endsec_location)
-    if (endsec_loc_lat == end_loc_lat and endsec_loc_lon == end_loc_lon):
-        return sensed_to_motion_type(cleaned_sections.iloc[section_counter]["sensed_mode"]), section_counter + 1
-    while endsec_loc_lat!= end_loc_lat and endsec_loc_lon!=end_loc_lon and section_counter < len(cleaned_sections) :
-        endsec_location = cleaned_sections.iloc[section_counter]["end_loc"]
-        endsec_loc_lat, endsec_loc_lon = geojson_to_lat_lon_separated(endsec_location)
-        if (sensed_to_motion_type(endsec_location) == "IN_VEHICLE"):
-            return sensed_to_motion_type(endsec_location), section_counter + 1
-        section_counter +=1
-    #PROBABLY NOT THE MOST ACCURATE WAY TO DETECT MODES, SINCE IT RELIES ON THE ENDING ENDSEC IF THERE AREN'T VEHICLE MOVEMENT
-    #(NOTE ***: COME UP WITH A BETTER ALGORITHM)
-    return sensed_to_motion_type(endsec_location), section_counter
-
-
-# Should return the section counter, so you know which index to start off with 
+
 '''
-New and cleaned up version of yelp-suggestion that detects if there is a better-reviewed place of the same 
-category near the user based on the trip point. 
+DUMMY HELPER FUNCTION TO TEST if server and phone side are connected
 '''
 
 def dummy_starter_suggestion(uuid):
@@ -388,9 +378,43 @@ def dummy_starter_suggestion(uuid):
         modes_from_trips[i], section_counter = most_used_mode_from_trip(cleaned_sections, real_cleaned_sections, section_counter, i)
     return modes_from_trips
 
+'''
+NOMINATIM VERSION: Function to find the review of the original location of the end point of a trip 
+'''
+def review_start_loc_nominatim(location = '0,0'):
+    try:
+        #Off at times if the latlons are of a location that takes up a small spot, especially boba shops
 
+        #IF RETURN_ADDRESS_FROM_LOCATION HAS A BUSINESS LOCATION ATTACHED TO THE ADDRESS
+        if (len(return_address_from_location_nominatim(location)) == 3):
+            address, address_dict = return_address_from_location_nominatim(location)
+            business_name = address_dict[list(address_dict.keys())[0]]
+            city = address_dict['city']
+        #print(business_reviews(API_KEY, business_name.replace(' ', '-') + '-' + city))
+            return business_reviews(YELP_API_KEY, business_name.replace(' ', '-') + '-' + city)['rating']
+    except:
+        try:
+            #This EXCEPT part may error, because it grabs a list of businesses instead of matching the address to a business
+            address, address_dict = return_address_from_location_nominatim(location)
+            return match_business_address(address)
+        except:
+            raise ValueError("Something went wrong")
 '''
+NOMINATIM
 In progress-nominatim yelp server suggestion function, first just trying to make end-to-end work before robustifying this function.
+
+Mode number correspondence: 
+0: "IN_VEHICLE"
+1: "BIKING"
+2: "ON_FOOT"
+3: "STILL"
+4: "UNKNOWN"
+5: "TILTING"
+7: "WALKING"
+8: "RUNNING"
+9: "NONE"
+10: "STOPPED_WHILE_IN_VEHICLE"
+11: "AIR_ON_HSR"
 '''
 def calculate_yelp_server_suggestion_nominatim(uuid):
     return_obj = { 'message': "Good job walking and biking! No suggestion to show.",
@@ -401,40 +425,41 @@ def calculate_yelp_server_suggestion_nominatim(uuid):
     time_series = esta.TimeSeries.get_time_series(user_id)
     cleaned_trips = time_series.get_data_df("analysis/cleaned_trip", time_query = None)
     real_cleaned_sections = time_series.get_data_df("analysis/inferred_section", time_query = None)
-    modes_from_trips = {}
+    # modes_from_trips = {}
     section_counter = 0
-    for i in range(len(cleaned_trips)):
-        modes_from_trips[i], section_counter = check_mode_from_trip(cleaned_trips, cleaned_sections, section_counter, i)
+    # for i in range(len(cleaned_trips)):
+    #     modes_from_trips[i], section_counter = check_mode_from_trip(cleaned_trips, cleaned_sections, section_counter, i)
     if len(cleaned_trips) == 0:
         return_obj['message'] = 'Suggestions will appear once you start taking trips!'
         return return_obj
     for i in range(len(cleaned_trips) - 1, -1, -1):
         distance_in_miles = cleaned_trips.iloc[i]["distance"] * 0.000621371
-        mode = modes_from_trips[i]
+        # mode = modes_from_trips[i]
         start_lat, start_lon = geojson_to_lat_lon_separated(cleaned_trips.iloc[i]["start_loc"])
         end_lat, end_lon = geojson_to_lat_lon_separated(cleaned_trips.iloc[i]["end_loc"])
         endpoint_categories = category_of_business_nominatim(end_lat, end_lon)
         business_locations = {}
         begin_string_address, begin_address_dict = return_address_from_location_nominatim(start_lat, start_lon)
         end_string_address, end_address_dict = return_address_from_location_nominatim(end_lat, end_lon)
-        city = end_address_dict["address"]["city"]
-        address = end_address_dict["display_name"]
+        city = end_address_dict["city"]
+        address = end_string_address
         end_lat_lon = end_lat + "," + end_lon
         location_review = review_start_loc(end_lat_lon)
         ratings_bus = {}
         error_message = 'Sorry, unable to retrieve datapoint'
         error_message_categor = 'Sorry, unable to retrieve datapoint because datapoint is a house or datapoint does not belong in service categories'
-        if (endpoint_categories):
-            for categor in endpoint_categories:
-                queried_bus = search(API_KEY, categor, city)['businesses']
-                for q in queried_bus:
-                    if q['rating'] >= location_review:
-                        #'Coordinates' come out as two elements, latitude and longitude
-                        ratings_bus[q['name']] = q['rating']
-                        obtained = q['location']['display_address'][0] + q['location']['display_address'][1] 
-                        obtained.replace(' ', '+')
-                        business_locations[q['name']] = obtained
-        else: 
+        try:
+            if (endpoint_categories):
+                for categor in endpoint_categories:
+                    queried_bus = search(YELP_API_KEY, categor, city)['businesses']
+                    for q in queried_bus:
+                            if q['rating'] >= location_review:
+                                #'Coordinates' come out as two elements, latitude and longitude
+                                ratings_bus[q['name']] = q['rating']
+                                obtained = q['location']['display_address'][0] + q['location']['display_address'][1] 
+                                obtained.replace(' ', '+')
+                                business_locations[q['name']] = obtained
+        except: 
             return {'message' : error_message_categor, 'method': 'bike'}
 
         #THIS PART WILL BE FIXED ACCODRING TO NOMINATIM AND GET RID OF MAPQUEST (find some other way to calculate distance)
@@ -449,9 +474,6 @@ def calculate_yelp_server_suggestion_nominatim(uuid):
                     #Still looking to see what to return with this message, because currently my latitude and longitudes are stacked together in one string
                     # insert_into_db(tripDict, i, yelp_suggestion_trips, uuid)
                     return {'message' : message, 'method': 'bike'}
-
-                    #insert_into_db(tripDict, trip_id, suggestion_trips, uuid)
-                    break
                 except ValueError as e:
                     continue
             elif calculate_distance < distance_in_miles and calculate_distance < 1:
@@ -460,7 +482,6 @@ def calculate_yelp_server_suggestion_nominatim(uuid):
                     " has better reviews, closer to your original starting point, and has a rating of " + str(ratings_bus[a])
                     # insert_into_db(tripDict, i, yelp_suggestion_trips, uuid)
                     return {'message' : message, 'method': 'walk'}
-                    break
                 except ValueError as e:
                     continue
             elif calculate_distance < distance_in_miles and calculate_distance >= 5 and calculate_distance <= 15:
@@ -469,7 +490,6 @@ def calculate_yelp_server_suggestion_nominatim(uuid):
                     " has better reviews, closer to your original starting point, and has a rating of " + str(ratings_bus[a])
                     # insert_into_db(tripDict, i, yelp_suggestion_trips, uuid)
                     return {'message' : message, 'method': 'public'}
-                    break
                 except ValueError as e:
                     continue
 
@@ -485,23 +505,17 @@ def calculate_yelp_server_suggestion(uuid):
     time_series = esta.TimeSeries.get_time_series(user_id)
     cleaned_sections = time_series.get_data_df("analysis/cleaned_trip", time_query = None)
     real_cleaned_sections = time_series.get_data_df("analysis/inferred_section", time_query = None)
-    yelp_suggestion_trips = edb.get_yelp_db()
     modes_from_trips = {}
     section_counter = 0
-    for i in range(len(cleaned_sections)):
-        modes_from_trips[i], section_counter = most_used_mode_from_trip(cleaned_sections, real_cleaned_sections, section_counter, i)
     
     if len(cleaned_sections) == 0:
         return_obj['message'] = 'Suggestions will appear once you start taking trips!'
         return return_obj
     for i in range(len(cleaned_sections) - 1, -1, -1):
         distance_in_miles = cleaned_sections.iloc[i]["distance"] * 0.000621371
-        mode = modes_from_trips[i]
         start_lat_lon = geojson_to_latlon(cleaned_sections.iloc[i]["start_loc"])
         end_lat_lon = geojson_to_latlon(cleaned_sections.iloc[i]["end_loc"])
-        # tripDict = yelp_suggestion_trips.find_one({'uuid': uuid})
         endpoint_categories = category_of_business(end_lat_lon)
-        # print(endpoint_categories)
         business_locations = {}
         if len(return_address_from_location_google(start_lat_lon))==1:
             begin_address = return_address_from_location_google(start_lat_lon)
diff --git a/emission/net/api/cfc_webapp.py b/emission/net/api/cfc_webapp.py
index b03fa925..fcff0e22 100644
--- a/emission/net/api/cfc_webapp.py
+++ b/emission/net/api/cfc_webapp.py
@@ -258,7 +258,7 @@ def getSuggestion():
   logging.debug("Called suggestion")
   user_uuid=getUUID(request)
   logging.debug("user_uuid %s" % user_uuid)
-  ret_dir = suggsys.calculate_yelp_server_suggestion(user_uuid)
+  ret_dir = suggsys.calculate_yelp_server_suggestion_nominatim(user_uuid)
   logging.debug("type(ret_dir) = %s" % type(ret_dir))
   logging.debug("Output of ret_dir = %s" % ret_dir)
   return ret_dir
diff --git a/emission/net/ext_service/geocoder/nominatim.py b/emission/net/ext_service/geocoder/nominatim.py
index 901f321c..76240606 100644
--- a/emission/net/ext_service/geocoder/nominatim.py
+++ b/emission/net/ext_service/geocoder/nominatim.py
@@ -15,18 +15,18 @@ from pygeocoder import Geocoder as pyGeo  ## We fall back on this if we have to
 
 try:
     googlemaps_key_file = open("conf/net/ext_service/googlemaps.json")
-    GOOGLE_MAPS_KEY = json.load(googlemaps_key_file)["api_key"]
+    GOOGLE_MAPS_KEY = json.load(googlemaps_key_file)["access_token"]
 except:
     print("google maps key not configured, falling back to nominatim")
 
 try:
     nominatim_file = open("conf/net/ext_service/nominatim.json")
-    NOMINATIM_QUERY_URL = json.load(nominatim_file)["query_url"]
+    NOMINATIM_QUERY_URL = json.load(nominatim_file)["base_url"]
 except:
     print("nominatim not configured either, place decoding must happen on the client")
 
 class Geocoder(object):
-
+ 
     def __init__(self):
         pass
         
